procedure StartWait(CmdLine:string;Timeout:DWORD=INFINITE);
var
si:Tstartupinfo;
p:Tprocessinformation;
CD:String;
begin
fillChar( Si, SizeOf( Si ) , 0 );
with Si do  begin
cb := SizeOf( Si);
//dwFlags := STARTF_USESHOWWINDOW;
wShowWindow:=SW_SHOWNORMAL;
end;
cd:=CmdLine;
CD:=ProcessPath(getfirstword(cd),PPPT_PARENTDIR);
If CD='' then CD:=GetCurDir;
CreateProcess(nil,pChar(CmdLine),nil,nil,false,Create_default_error_mode,nil,PChar(CD),si,p);
WaitForSingleObject(p.hProcess,Timeout);
end;//startwait

Function Run(Cmd:String;show:Boolean=False):Boolean;
Begin
result:=WinExec(PChar(cmd), iif(show,SW_Show,SW_Hide)) > 31;
End;

function GetDosOutput(const CmdLine:string;Params:String):string;overload; 
var 
  SA: TSecurityAttributes; 
  SI: TStartupInfo; 
  PI: TProcessInformation; 
  StdOutPipeRead, StdOutPipeWrite: THandle; 
  WasOK: Boolean;
  Buffer: array[0..255] of Char;
  BytesRead: Cardinal; 
  WorkDir, Line: String; 
begin 
  with SA do 
  begin 
    nLength := SizeOf(SA); 
    bInheritHandle := True; 
    lpSecurityDescriptor := nil; 
  end; 
  // создаём пайп для перенаправления стандартного вывода 
  CreatePipe(StdOutPipeRead,  // дескриптор чтения 
             StdOutPipeWrite, // дескриптор записи 
             @SA,              // аттрибуты безопасности 
             0                // количество байт принятых для пайпа - 0 по умолчанию 
             );

    // Создаём дочерний процесс, используя StdOutPipeWrite в качестве стандартного вывода, 
    // а так же проверяем, чтобы он не показывался на экране. 
    with SI do 
    begin 
      FillChar(SI, SizeOf(SI), 0); 
      cb := SizeOf(SI); 
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES; 
      wShowWindow := SW_HIDE; 
      hStdInput := GetStdHandle(STD_INPUT_HANDLE); // стандартный ввод не перенаправляем 
      hStdOutput := StdOutPipeWrite; 
      hStdError := StdOutPipeWrite; 
    end; 

    // Запускаем компилятор из командной строки
    WorkDir := ProcessPath(CmdLine,PPPT_PARENTDIR);
    WasOK := CreateProcess(PChar(CmdLine),PChar(Params) ,nil, nil, True, 0, nil, PChar(WorkDir), SI, PI); 

    // Теперь, когда дескриптор получен, для безопасности закрываем запись. 
    // Нам не нужно, чтобы произошло случайное чтение или запись. 
    CloseHandle(StdOutPipeWrite);  
    // если процесс может быть создан, то дескриптор, это его вывод 
    if WasOK then
        // получаем весь вывод до тех пор, пока DOS-приложение не будет завершено 
        Line := ''; 
        repeat 
          // читаем блок символов (могут содержать возвраты каретки и переводы строки) 
          WasOK := ReadFile(StdOutPipeRead, Buffer, 255, BytesRead, nil); 

          // есть ли что-нибудь ещё для чтения? 
          if BytesRead > 0 then 
          begin 
            // завершаем буфер PChar-ом 
            Buffer[BytesRead] := #0; 
            // добавляем буфер в общий вывод 
            Line := Line + Buffer; 
          end; 
        until not WasOK or (BytesRead = 0); 
        // ждём, пока завершится консольное приложение 
        WaitForSingleObject(PI.hProcess, INFINITE); 
        // Закрываем все оставшиеся дескрипторы 
        CloseHandle(PI.hThread); 
        CloseHandle(PI.hProcess); 
      result:=Line;
      CloseHandle(StdOutPipeRead);
end; 




function GetDosOutput(const CmdLine:string): string;overload;
var 
  SA: TSecurityAttributes; 
  SI: TStartupInfo; 
  PI: TProcessInformation; 
  StdOutPipeRead, StdOutPipeWrite: THandle; 
  WasOK: Boolean;
  Buffer: array[0..255] of Char;
  BytesRead: Cardinal; 
  WorkDir, Line: String; 
begin 
  with SA do 
  begin 
    nLength := SizeOf(SA); 
    bInheritHandle := True; 
    lpSecurityDescriptor := nil; 
  end; 
  // создаём пайп для перенаправления стандартного вывода 
  CreatePipe(StdOutPipeRead,  // дескриптор чтения 
             StdOutPipeWrite, // дескриптор записи 
             @SA,              // аттрибуты безопасности 
             0                // количество байт принятых для пайпа - 0 по умолчанию 
             );

    // Создаём дочерний процесс, используя StdOutPipeWrite в качестве стандартного вывода, 
    // а так же проверяем, чтобы он не показывался на экране. 
    with SI do 
    begin 
      FillChar(SI, SizeOf(SI), 0); 
      cb := SizeOf(SI); 
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES; 
      wShowWindow := SW_HIDE; 
      hStdInput := GetStdHandle(STD_INPUT_HANDLE); // стандартный ввод не перенаправляем 
      hStdOutput := StdOutPipeWrite; 
      hStdError := StdOutPipeWrite; 
    end; 

    // Запускаем компилятор из командной строки
    WorkDir := ProcessPath(CmdLine,PPPT_PARENTDIR);
    WasOK := CreateProcess(nil, PChar(CmdLine), nil, nil, True, 0, nil, PChar(WorkDir), SI, PI); 

    // Теперь, когда дескриптор получен, для безопасности закрываем запись. 
    // Нам не нужно, чтобы произошло случайное чтение или запись. 
    CloseHandle(StdOutPipeWrite);  
    // если процесс может быть создан, то дескриптор, это его вывод 
    if WasOK then
        // получаем весь вывод до тех пор, пока DOS-приложение не будет завершено 
        Line := ''; 
        repeat 
          // читаем блок символов (могут содержать возвраты каретки и переводы строки) 
          WasOK := ReadFile(StdOutPipeRead, Buffer, 255, BytesRead, nil); 

          // есть ли что-нибудь ещё для чтения? 
          if BytesRead > 0 then 
          begin 
            // завершаем буфер PChar-ом 
            Buffer[BytesRead] := #0; 
            // добавляем буфер в общий вывод 
            Line := Line + Buffer; 
          end; 
        until not WasOK or (BytesRead = 0); 
        // ждём, пока завершится консольное приложение 
        WaitForSingleObject(PI.hProcess, INFINITE); 
        // Закрываем все оставшиеся дескрипторы 
        CloseHandle(PI.hThread); 
        CloseHandle(PI.hProcess); 
      result:=Line;
      CloseHandle(StdOutPipeRead);
end; 

